stages:
  - build

build:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug # Usa la imagen de Kaniko
    entrypoint: [''] # Elimina el entrypoint predeterminado
  variables:
    # Variables para el registro del GitLab
    DOCKER_REGISTRY: $CI_REGISTRY # La URL del registry de GitLab (registry.gitlab.com)
    DOCKER_REGISTRY_IMAGE: $CI_REGISTRY_IMAGE # El nombre del proyecto en el registry
  before_script:
    - apk add --no-cache git # Instala git en la imagen de Kaniko
  script:
    - echo "Project ID - ${CI_PROJECT_ID}"
    - echo "Merge Request IID - ${CI_MERGE_REQUEST_IID}"
    - echo "Commit SHA - ${CI_COMMIT_SHA}"

    # Ensure we have a full clone
    - git fetch --unshallow || echo "Already a full clone"

    # Identify affected apps by this commit
    - echo "Identifying affected apps by this commit..."
    - APPS_CHANGED=$(git diff --name-only origin/main...$CI_COMMIT_SHA | grep '^apps/' | cut -d'/' -f2 | sort -u)

    # Define a tag for the image using el hash del commit y el ID de la merge request
    - IMAGE_TAG="${CI_COMMIT_SHA:0:8}-${CI_MERGE_REQUEST_IID}"
    - echo "Using image tag - $IMAGE_TAG"

    # Loop through affected apps and build them con Kaniko
    - |
      if [ -n "$APPS_CHANGED" ]; then
        echo "Changed apps: $APPS_CHANGED";
        for app in $APPS_CHANGED; do
          echo "Building image for $app";
          /kaniko/executor --context "${CI_PROJECT_DIR}/apps/$app" \
            --dockerfile "${CI_PROJECT_DIR}/apps/$app/Dockerfile.prod" \
            --destination $DOCKER_REGISTRY_IMAGE/$app:$IMAGE_TAG;  # Env√≠a la imagen al registry de GitLab
        done;
      else
        echo "No affected apps found.";
      fi
  tags:
    - kaniko
